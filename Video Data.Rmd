---
title: "Video Data"
output: html_document
---

## Start up chunk ##

Prep libraries and import datasheets
```{r}

library(tidyverse)
library(coxme)
library(survival)
library(stringr)

video_events <- read_csv("video Notable Events.csv")
video_morts <- read_csv("Mort Counts for Vid Analysis.csv")
no_event_vids <- read_csv("No Event Videos.csv")
video_times <- read_csv("Video Start and Stop Times.csv")
isolated_counts <-read.csv("Isolated_Counts.csv")
halfday_morts <-read.csv("Morts by half day.csv")
treatments_morts_dets <-read.csv("survival_for_curve_plusCauseAndMoult.csv")

#Getting rid of extra spaces that result in fake categories
treatments_morts_dets <- treatments_morts_dets %>%
  mutate(Cause = str_trim(Cause))
```

## Data Wrangling ##

Joining event data sheet with start/stop time sheet and manipulating to create a variable column for real event dates and times
```{r}
#Test events (lights off known time 20:00) show all notable event times coming out within 1.5 seconds of each other accross cameras and within 1.5 seconds of the correct time (20:00). This should be more than sufficient for the timescales I'm working on. 

realtime_events <- video_events %>%
   left_join(video_times, by = "video_code")

realtime_events <- realtime_events %>%
  mutate(
     start_datetime = as.POSIXct(paste(date.x, start), format = "%d-%b-%y %H:%M:%S")) %>%
   separate(timestamp, into = c("hh", "mm", "ss"), sep = ":", convert = TRUE) %>%
  mutate(
    timestamp_seconds = hh * 60 + mm, #what timestamp recognizes as hour is actually minute, minute is second
    real_timestamp_secs  = timestamp_seconds * 29.97,,
    real_timestamp_hms  = seconds_to_period(real_timestamp_secs),
    event_true_datetime = start_datetime + real_timestamp_hms
  ) %>%
  mutate(day_number = day_number - 1 ) %>%
  mutate(day_number = ifelse(time_of_day == "am", day_number + 0.5, day_number + 1))


```

Adding AM/PM and rough time chunks to mortality details summary data frame
```{r}
treatments_morts_dets <- treatments_morts_dets %>%
  mutate(time = ifelse(Day %% 1 == 0, "Night", "Day")) %>%
  mutate(third = case_when(
    Day < 10 ~ "Early",
    Day >= 10 & Day < 20 ~ "Mid",
    Day >= 20 ~ "Late"
  ))

```


Summary table event counts for ease of graphing 
```{r}
events_summary <- realtime_events %>%
  mutate(event_true_date = as.Date(event_true_datetime)) %>% # this is important because in the original date column the date is the day the video started not the actual date (ie things that happen after midnight are not technically the correct date in the original)
  group_by(camera.x, event_true_date, event_type) %>%
  summarise(count = n(), .groups = "drop")
```


Making appropriate data frame for survival curve
```{r}
halfday_morts_long <-halfday_morts %>%
  pivot_longer(
    cols = starts_with("Morts"),
    names_to = "Tank",
    values_to = "Morts"
  )

expanded_morts <- halfday_morts_long %>%
  filter(Morts > 0) %>%
  uncount(weights = Morts, .id = "death_num") %>%
  mutate(
    status = 1  # died
  )

start_counts <- data.frame(
  Tank = c("Morts.I", "Morts.1", "Morts.2", "Morts.3", "Morts.4"),
  start_n = c(44, 11, 11, 11, 11),
  treatment = c("individual", "group", "group", "group", "group")
)

total_morts <- expanded_morts %>%
  count(Tank, name = "Morts")

survivors <- start_counts %>%
  left_join(total_morts, by = "Tank") %>%
  mutate(
    Morts = replace_na(Morts, 0),
    survivors = start_n - Morts
  ) %>%
  filter(survivors > 0) %>%
  uncount(weights = survivors, .id = "survivor_num") %>%
  mutate(
    Day = 30,
    status = 0
  )

survival_data <- bind_rows(
  expanded_morts %>% select(Tank, Day, status),
  survivors %>% select(Tank, Day, status)
) %>%
  left_join(start_counts %>% select(Tank, treatment), by = "Tank") %>%
  mutate(ID = row_number())

survival_for_curve <- survival_data %>%
  group_by(Tank) %>%
  mutate(
    # assign a unique ID *within each tank*
    ID = paste0(Tank, "_", row_number())
  ) %>%
  ungroup()

```


## Survival modeling and visualization between group and individual treatments ##

Kaplan-meier curves and log-rank test for diff between curves, no ability to cluster by tank within group treatment
```{r}

#Make curve df without individuals
survivalCurve_groupOnly <- survival_for_curve %>%
  filter(treatment == "group")

#surv curves for individual vs. group putting all grouped tanks together as a treatment
surv_obj <- Surv(time = survival_for_curve$Day, event = survival_for_curve$status)


survdiff(surv_obj ~ treatment, data = survival_for_curve) #Performs log-rank test to look for differences between survival curves. this groups all the tanks together so it's just grouped vs individual as big groups, cox needed to seperate i think

#surv curves for group only by tank to make sure they aren't significantly different
surv_objGROUP <- Surv(time = survivalCurve_groupOnly$Day, event = survivalCurve_groupOnly$status)
survdiff(surv_objGROUP ~ Tank, data = survivalCurve_groupOnly)


#Kaplan Myer fit with each tank seperated out for visualization
survival_for_curve$tank_or_indiv <- ifelse(is.na(survival_for_curve$Tank), "individual", survival_for_curve$Tank)

# tanks graphed separately
km_fit <- survfit(Surv(Day, status) ~ tank_or_indiv, data = survival_for_curve)

#base r plot of kaplan meier with all tanks separated to show they have similar pattern

plot(km_fit, 
     xlab = "Time (Days)", 
     ylab = "Survival Probability",
     lwd = 2, col = c("turquoise3", "steelblue3", "navyblue", "slategray4", "palegreen3" )) # change pale green to #FF000000 to temporarily remove individual line for presentation plot

# Open a new plotting window (or PDF/PNG) to generate separate figure for legend so it is not ugly
dev.new()  # on RStudio or base R; for saving use png()/pdf()

# Empty plot
plot.new()

#generate legend for prev graph
legend("center", legend = c("Tank 1", "Tank 2", "Tank 3", "Tank 4", "Individuals"),
       col = c("turquoise3", "steelblue3", "navyblue", "slategray4", "palegreen3" ), lwd = 2)  


#tanks graphed together
km_fit_lumped <- survfit(Surv(Day, status) ~ treatment, data = survival_for_curve)

plot(km_fit_lumped, 
     xlab = "Time (Days)", 
     ylab = "Survival Probability",
     lwd = 2, col = c("steelblue3", "palegreen3" ))

# Open a new plotting window (or PDF/PNG) to generate separate figure for legend so it is not ugly
dev.new()  # on RStudio or base R; for saving use png()/pdf()

# Empty plot
plot.new()

#generate legend for prev graph
legend("center", legend = c( "Co-reared", "Isolated"),
       col = c("steelblue3", "palegreen3" ), lwd = 2)

```

KM for cannibalism by moult stage (this is sort of weird, not sure if it's a good representation)
```{r}

#Make curve df for cannibalism by moult stage, censors pure moult failure death
survivalCurve_cann <- treatments_morts_dets %>%
  filter(treatment == "group") %>%
  mutate(status = ifelse(Cause == "Moult Failure", 0, status))
  
#log rank between stages
surv_objCANN <- Surv(time = survivalCurve_cann$Day, event = survivalCurve_cann$status)
survdiff(surv_objCANN ~ Stage, data = survivalCurve_cann)

# curve for just group morts that involved cannibalism by moult stage
km_fit_cann <- survfit(Surv(Day, status) ~ Stage, data = survivalCurve_cann)


#base r plot of kaplan meier with all tanks separated to show they have similar pattern

plot(km_fit_cann, 
     xlab = "Time (Days)", 
     ylab = "Survival Probability",
     lwd = 2, col = c("slategray4", "navyblue", "turquoise3", "steelblue3" )) 

# Open a new plotting window (or PDF/PNG) to generate separate figure for legend so it is not ugly
dev.new()  # on RStudio or base R; for saving use png()/pdf()

# Empty plot
plot.new()

#generate legend for prev graph
legend("center", legend = c( "Co-reared", "Isolated"),
       col = c("steelblue3", "palegreen3" ), lwd = 2)
```


## Cox Models ##

Base Cox model + models for clustering
```{r}

#Base cox model for treatment, does not meet ph
fit_cox <- coxph(surv_obj ~ treatment, data = survival_for_curve)
print(summary(fit_cox))

zph <- cox.zph(fit_cox)
print(zph)
plot(zph) 


# Clustering models below. Neither of these are appropriate given small number of clusters. Base cox run with all replicates as seperate treatments finds no difference between tanks but a difference between each tank and individuals. Did not check ph for this yet, but hoping it can be used to justify not using clustering models because apparently they blow things up. 

# (A) Cox mixed-effects model with tank random intercept (frailty) using coxme
# This treats each group tank as a clustering level ; for individual animals their 'tank' is unique. Treats tank as random effect, assumes each tank has random baseline hazard and estimates variance componant at tank level. Gives fixed effect for treatment and random effect for tank variance. Useful to model tank-to-tank heterogeneity explicitly, not just adjust SEs, output includes frailty variance, but p-values may be approximate.
fit_coxme <- coxme(surv_obj ~ treatment + (1 | Tank), data = survival_for_curve)
print(summary(fit_coxme))

# (B) Alternative: Cox proportional hazards with cluster-robust SE (no random effect estimate). Treats tanks as clusters for robust SEs rather than random effects. Gives treatment effect only but adjusts standard error to account for in-tank correlation. Treatment HR is effect at pop level, SEs and P values should be robust to in-tank correlation. No random effect estimate, so donâ€™t get tank-specific baseline hazards, but I think that's ok because hazard seems vary by time anyway and tanks appear to have similar baseline hazard. I went with this model.
fit_coxph_cluster <- coxph(surv_obj ~ treatment + cluster(Tank), data = survival_for_curve)
summary(fit_coxph_cluster)

# PH assumption check for Cox model (note: coxme has limitations here, PH must be consistant over time, shown by horiz lines on plot check)
# ---------------------------
#for the cox me model:
zph <- cox.zph(fit_coxme)
print(zph)
plot(zph) 

# For the coxph(cluster) model:
zph <- cox.zph(fit_coxph_cluster)
print(zph)
plot(zph)  

# visual check: lines close to horizontal indicate PH reasonable
#Not so, it seems proportional hazard of death between individual and group may change over time, makes sense, few individual deaths toward end. P values of zph indicate the same in both cases

AIC(fit_coxme, fit_coxph_cluster)

# AICs are comperable
```

Time varying options for cox model to show increase in hazard for co-reared late compared to early
```{r}
#Is one or the other of these better? PH assumption can't be tested for TV because it obviously is intended to vary by time. Assumption is met for interval. Report both? 

# Cox model with time-varying coefficient for treatment. tt term allows for interaction with log(time) to address the fact that the PH is not the same over time. Treatment is not significant, time-treatment is significant. Chat tells me this means there isn't a significant impact at the beginning but it increases significantly over time? True? 
survival_for_curve <- survival_for_curve %>%
mutate(treat_num = ifelse(survival_for_curve$treatment == "group", 1, 0) ) %>%
  mutate(third = ifelse((Day <= 10), "early", ifelse((Day > 10 & Day <= 20), "mid", "late")))


cox_tv <- coxph(Surv(Day, status) ~ treatment + tt(treat_num),
                data = survival_for_curve,
                tt = function(x, t, ...) x * log(t))  

summary(cox_tv)


# Stratified by first week vs. rest, shows significant impact of treatment at beginning and significant increase in hazard after first week. I think.

coxstrat_long <- survSplit(Surv(Day, status) ~ .,
                     data = survival_for_curve,
                     cut = 7,
                     start = "tstart",
                     end = "tstop",
                     event = "status",
                     id = "splitID")

coxstrat_long <- coxstrat_long %>%
  mutate(interval = cut(tstart,
                        breaks = c(0, 7, Inf),
                        labels = c("early", "rest"),
                        right = FALSE)) %>%
  # for rows with tstart == 0 the first cut created NA from above; recalc robustly:
  mutate(interval = case_when(
    tstart < 7 ~ "early",
    tstart == 7 ~ "rest",
    TRUE ~ interval
  )) %>%
  mutate(interval = factor(interval, levels = c("early","rest")))

cox_interval <- coxph(Surv(tstart, tstop, status) ~ treatment * interval, data = coxstrat_long)
summary(cox_interval)

zph <- cox.zph(cox_interval)
print(zph)
plot(zph)




```

Testing if linear or log-transformed t covariate cox is a better model 
```{r}
# Results are essentially the same, log AIC result is like 0.5 higher which allegedly means the models both fit about equally well. Go with log because everyone loves log time? 

cox_linear <- coxph(Surv(Day, status) ~ treat_num + tt(treat_num) + cluster(Tank), 
                    data = survival_for_curve, 
                    tt = function(x,t,...) x*t)

cox_log <- cox_tv  # current model with log(t)

AIC(cox_linear, cox_log)
```

## Logistic Regressions ##

Moult stage x cannibalism binary logistic regression
```{r}
# Binary encode cause
cann_by_moult <- treatments_morts_dets %>%
  filter(treatment == "group") %>% 
  filter(status == 1) %>%  
  filter(Cause != "Moult Failure") %>% # includes all animals where cannibalism was a componant of death, including the + moult failures
  mutate(moult_bin = ifelse(Stage == "Post-moult", 1, ifelse(Stage == "Moulting", 1, 0)))


# Binomial logistic regression for moult stage by day of experiemnt
binom_calcif_day <- glm(moult_bin ~ Day, data = cann_by_moult, family = binomial)
summary(binom_calcif_day)

# by time of day (day/night)
binom_calcif_time <- glm(moult_bin ~ time, data = cann_by_moult, family = binomial)
summary(binom_calcif_time)

# by both day and time of day (this has the lowest AIC of the three and both predictors are significant, a bit concerned about over fitting but I think it's ok?)
binom_calcif_day_time <- glm(moult_bin ~ Day + time, data = cann_by_moult, family = binomial)
summary(binom_calcif_day_time)

# Need to fix formatting on these to make it less ugly, add theme created for presentaiton

# Calcified vs. Uncalcified over course of experiment
ggplot(cann_by_moult, aes(x = Day, y = moult_bin)) +
  geom_jitter(height = 0.05, width = 0) +
  geom_smooth(method = "glm", method.args = list(family = "binomial"),
              se = TRUE, color = "blue") +
  ylab("Probability Cannibalism Victim is Moulting/Post-Moult") +
  xlab("Days")


# Calcified vs. Uncalcified by time of day
ggplot(cann_by_moult, aes(x = time, y = moult_bin)) +
  geom_jitter(height = 0.05, width = 0) +
  geom_smooth(method = "glm", method.args = list(family = "binomial"),
              se = TRUE, color = "blue") +
  ylab("Probability Cannibalism Victim is Moulting/Post-Moult") +
  xlab("Days")

# Calcified vs. uncalcified by time and day

# Create a new dataset for prediction
newdat <- expand.grid(
  Day = seq(min(cann_by_moult$Day), max(cann_by_moult$Day), length.out = 100),
  time = c("Day", "Night"))

# Get predicted values and standard errors on the link (logit) scale
pred <- predict(binom_calcif_day_time, newdata = newdat, type = "link", se.fit = TRUE)

# Add fitted values and confidence intervals (on probability scale)
newdat$fit <- plogis(pred$fit)
newdat$lwr <- plogis(pred$fit - 1.96 * pred$se.fit)
newdat$upr <- plogis(pred$fit + 1.96 * pred$se.fit)

# Plot with ribbons for 95% CIs
ggplot(newdat, aes(x = Day, y = fit, color = time, fill = time)) +
  geom_line() +
  geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.2, color = NA) +
  labs(
    y = "Predicted probability (non-calcified cannibalism)",
    x = "Experimental day",
    color = "Time of day",
    fill = "Time of day"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "right",
    plot.title = element_text(hjust = 0.5),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.title.x = element_text(margin = margin(t = 15)),
    axis.title.y = element_text(margin = margin(r = 15)),
    axis.line = element_line(color = "black")
  )


# plot without CI

# Create prediction data
newdat1 <- expand.grid(
  Day = seq(min(cann_by_moult$Day), max(cann_by_moult$Day), length.out = 100),
  time = c("Day", "Night")
)

# Get predicted probabilities
newdat1$pred <- predict(binom_calcif_day_time, newdata = newdat, type = "response")

#plot
ggplot(newdat1, aes(x = Day, y = pred, color = time)) +
  geom_line(size = 1.2) +
  labs(y = "Probability that Cannibalized Animal Was Not Calcified",
       color = "Time of day") +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "right",
    plot.title = element_text(hjust = 0.5),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.title.x = element_text(margin = margin(t = 15)),
    axis.title.y = element_text(margin = margin(r = 15)),
    axis.line = element_line(color = "black")
  )

```

Binary logistic regression for mortality between treatments.
```{r}

mort_treat <- treatments_morts_dets %>%
  filter(status == 1) %>%  
  mutate(treat_bin = ifelse(treatment == "individual", 0, 1))

binom_mort_treat <- glm(treat_bin ~ Day, data = mort_treat, family = binomial)
summary(binom_mort_treat)

ggplot(mort_treat, aes(x = Day, y = treat_bin)) +
  geom_jitter(height = 0.05, width = 0) +
  geom_smooth(method = "glm", method.args = list(family = "binomial"),
              se = TRUE, color = "blue") +
  ylab("Probability Of death between treatments") +
  xlab("Days")


```

Binary logistic regression for co-reared mortality between light and dark.
```{r}

mort_by_light <- video_events %>%
  filter(event_type == "Mortality") %>%
  mutate(light_bin = ifelse(time_of_day == "am", 1, 0))

binom_mort_light <- glm(light_bin ~ day_number, data = mort_by_light, family = binomial)
summary(binom_mort_light)

ggplot(binom_mort_light, aes(x = day_number, y = light_bin)) +
  geom_jitter(height = 0.05, width = 0) +
  geom_smooth(method = "glm", method.args = list(family = "binomial"),
              se = TRUE, color = "blue") +
  ylab("Probability Of death between light and dark") +
  xlab("Days")


```

Binary logistic regression for co-reared moults between light and dark.
```{r}

simple_moult <- video_events %>%
  filter(event_type == "Moult")

moult_by_light <- simple_moult %>%
  mutate(light_bin = ifelse(time_of_day == "am", 1, 0))

binom_moult_light <- glm(light_bin ~ day_number, data = moult_by_light, family = binomial)
summary(binom_moult_light)

ggplot(binom_moult_light, aes(x = day_number, y = light_bin)) +
  geom_jitter(height = 0.05, width = 0) +
  geom_smooth(method = "glm", method.args = list(family = "binomial"),
              se = TRUE, color = "blue") +
  ylab("Probability Of moult between light and dark") +
  xlab("Days")


```

## Chi square/Fisher exact for comparisons without continuous time componant ##

Data formatting
```{r}

#Attributing the causese that include both moult failure and cannibalism to the 'primary' cause of mortality IE did it start struggling with moulting or have a cannibalism attempt first? 
treatments_morts_simplify <- treatments_morts_dets %>%
filter( status == 1) %>%
  mutate(Cause = ifelse(Cause == "Moult Failure + Cannibalism", "Moult Failure", Cause)) %>%
mutate(Cause = ifelse(Cause == "Cannibalism + Moult Failure", "Cannibalism", Cause)) 

simplify_group <- treatments_morts_simplify %>%
  filter(treatment == "group")

simple_moult <- video_events %>%
  filter(event_type == "Moult")

  
ctable_cause <- xtabs(~ treatment + Cause, data = treatments_morts_simplify) 
ctable_stage <- xtabs(~ treatment + Stage, data = treatments_morts_simplify) 
ctable_time <- xtabs(~ treatment + time, data = treatments_morts_simplify) 

ctable_group_cause <- xtabs(~ third + Cause, data = simplify_group)
ctable_tank_cause <- xtabs(~ Tank + Cause, data = simplify_group)
ctable_tank_time <- xtabs(~ Tank + time, data = simplify_group)
ctable_moult_tank_time <- xtabs(~ camera + time_of_day, data = simple_moult)

# Difference between cannibalism cause and moult cause deaths in group, shapiro wilk test says not normal so used wilcoxen
wilcox.test(ctable_moult_tank_time)

Day <- c(2,3,4,5)
Night <- c(7,7,4,5)

diffs <- Day - Night
shapiro.test(diffs)

fisher_cause <- fisher.test(ctable_tank_time)
fisher_cause


fisher_by_category(ctable_cause)


#code to look at chi square residuals as another check to see what's influencing significant differences (even if doesn't meet assumptions for chi), internet says absolute >2 is usually impactful
chi <- chisq.test(ctable_time, simulate.p.value = TRUE)
residuals <- (ctable_time - chi$expected) / sqrt(chi$expected)
residuals
```


Specific tests for slides
```{r}
#following can be used with moult stage of mort etc. as well
counts_stage_tank <- video_events %>%
  #filter(treatment == "group") %>%
  filter(mort_cause == "Cannibalism") %>%
 # filter(mort_moult_stage )
  filter (event_type == "Mortality") %>%
  group_by(camera, mort_moult_stage) %>%
  summarise(count = n(), .groups = "drop") 
 
  shapiro.test(counts_stage_tank$count) 
  qqnorm(counts_stage_tank$count)
qqline(counts_stage_tank$count, col = "red")

cst_wide <- counts_stage_tank %>%
  pivot_wider(names_from = time_of_day, values_from = count, values_fill = 0)

friedman.test(as.matrix(cst_wide[, c("am", "pm")]))

pairwise.wilcox.test(
  x = c(cst_wide$am, cst_wide$pm),
  g = rep(c("am","pm"), each = nrow(cst_wide)),
  paired = TRUE,
  p.adjust.method = "holm"
)

wilcox.test(count ~ time_of_day, data = counts_stage_tank, paired = TRUE)
#--------------------------------------------------------------------------
counts_stage_third <- treatments_morts_simplify %>%
   filter(treatment == "group") %>%
  filter(Cause == "Cannibalism") %>%
  group_by (third, Stage) %>%
  summarise(count = n(), total = sum(count), .groups = "drop") %>%
  pivot_wider(names_from = Stage, values_from = total, values_fill = 0)

mat <- as.matrix(counts_stage_third[, c("Pre-moult","Moulting","Post-moult", "Inter-moult")])
rownames(mat) <- counts_stage_third$third

fisher.test(mat)      


```

Function to run pairwise fisher for each category table columns
```{r}

fisher_by_category <- function(tab) {
results <- sapply(1:ncol(tab), function(i) {
  tmp <- tab[, i, drop = FALSE]  # 2x1 column
  # Make 2x2 table: cause vs all other deaths
  cause_table <- matrix(c(tab[1, i], sum(tab[1, -i]),
                          tab[2, i], sum(tab[2, -i])),
                        nrow = 2, byrow = TRUE)
  fisher.test(cause_table)$p.value
})

# Adjust for multiple testing (optional)
results_adj <- p.adjust(results, method = "bonferroni")

# Combine into a tidy table
cause_results <- data.frame(
  Cause = colnames(tab),
  raw_p = results,
  bonferroni_p = results_adj
)

cause_results
}
```

Function to run all possible pairwaise fishers to determine where differences lie
```{r}
pairwise_fisher_heat <- function(tab, alpha = 0.05) {
  if (!is.matrix(tab) & !is.table(tab)) stop("Input must be a matrix or table.")
  if (nrow(tab) < 2) stop("Table must have at least 2 rows for pairwise comparison.")
  
  # Generate all pairwise combinations of rows
  row_pairs <- combn(rownames(tab), 2, simplify = FALSE)
  
  results <- lapply(row_pairs, function(p) {
    subtab <- tab[p, , drop = FALSE]  # 2xN table
    res <- fisher.test(subtab)
    data.frame(
      row1 = p[1],
      row2 = p[2],
      raw_p = res$p.value
    )
  })
  
  # Combine results
  df <- do.call(rbind, results)
  
  # Bonferroni correction
  df$bonferroni_p <- p.adjust(df$raw_p, method = "bonferroni")
  
  # Flag significant comparisons
  df$significant <- df$bonferroni_p < alpha
  
  # Create matrix-style heat (optional)
  sig_matrix <- matrix(FALSE, nrow = nrow(tab), ncol = nrow(tab),
                       dimnames = list(rownames(tab), rownames(tab)))
  for (i in 1:nrow(df)) {
    r1 <- df$row1[i]
    r2 <- df$row2[i]
    sig_matrix[r1, r2] <- df$significant[i]
    sig_matrix[r2, r1] <- df$significant[i]  # symmetric
  }
  
  return(list(pairwise_results = df,
              significance_matrix = sig_matrix))
}

```

Function for testing if chi square or fisher exact is more appropriate based on expected counts in contingency table
```{R}

expecteds <- function(tab) {
  # tab = contingency table (matrix or from xtabs)
  
  # Run chi-square without printing immediately
  chi <- suppressWarnings(chisq.test(tab))
  
  # Return expecteds
  chi$expected
  
}

#run_chi_or_fisher(table_x)
```


### Data wrangling WORK IN PROGRESS for possible competing hazard model for cause of death, not current priority. Turns categoricals into number codes in the dataset formatted for survival curves
```{r}
# Turning words into numbers for easier modeling
# Causes of mortality
cause_map <- c("Cannibalism" = 1, "Moult Failure" = 2, "Moult Failure + Cannibalism" = 3, "Cannibalism + Moult Failure" = 4, "Unknown" = 5)
treatments_morts_dets$Cause <- cause_map[treatments_morts_dets$Cause]

# Moult stage
moult_map <- c("Pre-moult" = 1, "Moulting" = 2, "Post-moult" = 3, "Unknown" = 4)
treatments_morts_dets$Stage <- moult_map[treatments_morts_dets$Stage]
```


### Obnoxious Bar Graphs for initial visualization ###

Bar chart for notable events in dif cams
```{r}
#create bar chart showing notable events sans test times and feeds accross all cams
video_events %>%
  group_by(event_type, camera) %>%
  filter(event_type != "Test") %>%
  filter(event_type != "Feed") %>%
  summarize(count = n()) %>%
  ggplot(aes(x = event_type, y = count, fill = factor(camera))) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Notable Events by Camera",
       x = "Event",
       y = "Count") +
  theme_minimal()

```

Bar chart showing notable events by time of day (error bars)
```{r}

dodge <- position_dodge(width = 0.9)  # define once

video_events %>%
  filter(!event_type %in% c("Test", "Feed")) %>%
 group_by(event_type, camera, time_of_day) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(camera) %>%                          # calculate percent per Tank
  mutate(percent = count / sum(count) * 100) %>%
  group_by(event_type, time_of_day) %>%                         # summarise across Tanks
  summarise(
    mean_percent = mean(percent),
    sd_percent = sd(percent),
    se_percent = sd_percent / sqrt(n()),
    .groups = "drop"
  ) %>%
  
  ggplot(aes(x = event_type, y = mean_percent, fill = time_of_day)) +
  geom_col(color = "darkslategray", position = dodge) +
  geom_errorbar(
    aes(
      ymin = pmax(0, mean_percent - se_percent),
      ymax = mean_percent + se_percent
    ),
    width = 0.2,
    color = "black",
    position = dodge    # use same dodge object
  ) +
    geom_text(
    aes(label = sprintf("%.1f%%", mean_percent),y = mean_percent + se_percent + 1),
    vjust = -0.5,
    size = 4,
    color = "black",
    position = dodge
  ) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  scale_fill_manual(
    values = c("am" = "lightcyan2", "pm" = "darkslategray"),
    labels = c("am" = "Light", "pm" = "Dark")
  ) +
  labs(
    x = "Event",
    y = "Mean Percentage of Events (+/- SE)",
    fill = "Time of Day"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "right",
    plot.title = element_text(hjust = 0.5),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.title.x = element_text(margin = margin(t = 15)),
    axis.title.y = element_text(margin = margin(r = 15)),
    axis.line = element_line(color = "black")
  )

```

Bar chart showing cannibalism by moult stage AND time of day (error bars)
```{r}

 dodge <- position_dodge(width = 0.9)

video_events %>%
  filter(!event_type %in% c("Test", "Feed")) %>%
  filter(!is.na(mort_moult_stage)) %>%
  filter(mort_cause == "Cannibalism") %>%
  group_by(mort_moult_stage, camera, time_of_day) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(camera) %>%
  mutate(percent = count / sum(count) * 100) %>%
  group_by(mort_moult_stage, time_of_day) %>%
  summarise(
    n_obs = n(),
    mean_percent = if(n() > 1) mean(percent) else percent,
    sd_percent = if(n() > 1) sd(percent) else 0,
    se_percent = if(n() > 1) sd_percent / sqrt(n()) else 0,
    .groups = "drop"
  ) %>%
  ggplot(aes(x = mort_moult_stage, y = mean_percent, fill = time_of_day)) +
  geom_col(color = "darkslategray", position = dodge) +
  geom_errorbar(
    aes(
      ymin = pmax(0, mean_percent - se_percent),
      ymax = mean_percent + se_percent
    ),
    width = 0.2,
    color = "black",
    position = dodge
  ) +
  geom_text(
    aes(label = sprintf("%.1f%%", mean_percent), y = mean_percent + se_percent + 1),
    vjust = -0.5,
    size = 4,
    color = "black",
    position = dodge
  ) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  scale_fill_manual(
    values = c("am" = "lightcyan2", "pm" = "darkslategray"),
    labels = c("am" = "Light", "pm" = "Dark")
  ) +
  labs(
    x = "Moult Stage",
    y = "Mean Percentage of Cannibalism Occurrences (+/- SE)",
    fill = "Time of Day"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "right",
    plot.title = element_text(hjust = 0.5),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.title.x = element_text(margin = margin(t = 15)),
    axis.title.y = element_text(margin = margin(r = 15)),
    axis.line = element_line(color = "black")
  )
#Having the one 'moulting' bar is really ugly and hard to interpret, need to fix if using some iteration of this graph in presentation

```

Bar chart showing moults over time
```{r}
# Moults over the full experiment
moult_tally <- video_events %>%
  filter(event_type == "Moult") %>%   
  group_by(day_number, camera, time_of_day) %>%
  summarise(count = n(), .groups = "drop")

ggplot(moult_tally, aes(x = day_number)) +
  geom_freqpoly(binwidth = 1, size = 1.2, color = "steelblue") +
  labs(x = "Day", y = "Number of Moults") +
    theme_minimal(base_size = 14) +
  theme(
    legend.position = "none",
    plot.title = element_text(hjust = 0.5),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.title.x = element_text(margin = margin(t = 15)),
    axis.title.y = element_text(margin = margin(r = 15)),
    axis.line = element_line(color = "black")  # keeps axis lines
  )
```

Event count per day per tank bar graph using summary table
```{r}
events_summary %>%
  filter(event_type != "Test") %>%
  filter(event_type != "Feed") %>%

ggplot(aes(x = event_true_date, y = count, fill = event_type)) +
  geom_col(position = "dodge") +
  facet_wrap(~camera.x) +
  labs(x = "Date", y = "Count per day", fill = "Event Type") +
  theme_minimal()
```


## Other initial visualizations ##

Moult/Mort visualization by tank frequency point graph thingy, kind of cool visualization 
```{r}
realtime_events %>%
filter(event_type != "Test") %>%
  filter(event_type != "Feed") %>%
ggplot() +
  geom_point(aes(x = event_true_datetime, y = factor(camera.x), color = event_type), size = 3) +
  labs(x = "Time", y = "Tank", color = "Event Type") +
  theme_minimal()
```

## Plots for presentation ##

Bar plot percent mortality
```{r}
plot_data <- treatments_morts_dets %>%
  group_by(treatment) %>%
  summarise(
    num_dead = sum(status == 1),
    total = n(),
    percent_dead = (num_dead / total) * 100,
    mean = mean(percent_dead),
    se = sd(percent_dead) / sqrt(n()),   # standard error
    .groups = "drop"
  )
  

# Optional: order treatments from lowest to highest mortality
plot_data <- plot_data %>%
  mutate(treatment = fct_reorder(treatment, percent_dead))

# Plot
ggplot(plot_data, aes(x = treatment, y = percent_dead, fill = treatment)) +
  geom_col(color = "black") +
  geom_text(aes(label = sprintf("%.1f%%", percent_dead)),
            vjust = -0.5, size = 4) + # adds % labels above bars
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) + # space for labels
  scale_fill_manual(values = c("individual" = "palegreen3", 
                               "group" = "steelblue3"))+ 
   scale_x_discrete(labels = c("individual" = "Isolated",
                              "group" = "Co-reared")) +
  geom_errorbar(aes(ymin = mean - se, ymax = mean + se),
                width = 0.2, size = 0.8) +
  labs(
    x = "Treatment",
    y = "Mortality (%)"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "none",
    plot.title = element_text(hjust = 0.5),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.title.x = element_text(margin = margin(t = 15)),
    axis.title.y = element_text(margin = margin(r = 15)),
    axis.line = element_line(color = "black")  # keeps axis lines
  )
  
```

Bar plot isolated treatment causes of mortality 
```{r}
treatments_morts_simplify %>%
  filter(treatment == "individual") %>%
    group_by(Cause) %>%
  summarise(count = n(), .groups = "drop") %>%
  mutate(percent = (count / sum(count)) * 100) %>%
  
  ggplot(aes(x = Cause, y = percent, fill = Cause)) +
  geom_col(position = "dodge", color = "black") +
   geom_text(aes(label = sprintf("%.1f%%", percent)),
            vjust = -0.5, size = 4) + # adds % labels above bars
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) + # space for labels
   scale_fill_manual(values = c("Moult Failure" = "palegreen3", 
                               "Unknown" = "darkolivegreen4"))+ 
   scale_x_discrete(labels = c("Moult Failure" = "Moult Failure",
                              "Unknown" = "General Attrition")) +
  labs(
    x = "Cause of Death",
    y = "Percentage of Mortalities"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "none",
    plot.title = element_text(hjust = 0.5),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.title.x = element_text(margin = margin(t = 15)),
    axis.title.y = element_text(margin = margin(r = 15)),
    axis.line = element_line(color = "black")  # keeps axis lines
  )
  
  
```

Bar for full causes of mortality co-reared
```{r}

treatments_morts_dets %>%
  filter(treatment == "group") %>%
  filter(status == 1) %>%
    group_by(Cause) %>%
   mutate(Cause = factor(Cause, levels = c("Cannibalism", "Moult Failure", "Cannibalism + Moult Failure", "Moult Failure + Cannibalism"))) %>% # Set order
  summarise(count = n(), .groups = "drop") %>%
  mutate(percent = (count / sum(count)) * 100) %>%
  
  ggplot(aes(x = Cause, y = percent, fill = Cause)) +
 geom_text(aes(label = sprintf("%.1f%%", percent)),
            vjust = -0.5, size = 4) + # adds % labels above bars
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) + # space for labels
  geom_col(position = "dodge", color = "black") +
   scale_fill_manual(values = c("Moult Failure" = "steelblue3",
                              "Cannibalism" = "royalblue4",
                              "Moult Failure + Cannibalism" = "cadetblue3", "Cannibalism + Moult Failure" = "slategray3"))+ 
   scale_x_discrete(labels = c("Moult Failure" = "Moult Failure",
                              "Cannibalism" = "Cannibalism",
                              "Moult Failure + Cannibalism" = "Moult Failure -> Cannibalism", "Cannibalism + Moult Failure" = "Cannibalism -> Moult Failure")) +
  labs(
    x = "Cause of Death",
    y = "Percentage of Mortalities"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "none",
    plot.title = element_text(hjust = 0.5),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.title.x = element_text(margin = margin(t = 15)),
    axis.title.y = element_text(margin = margin(r = 15)),
    axis.line = element_line(color = "black")  # keeps axis lines
  )
  
  
```

Bar for condensed cause of mortality co-reared (with error bars)
```{r}

treatments_morts_simplify %>%
   filter(treatment == "group") %>%
  group_by(Cause, Tank) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(Tank) %>%                          # calculate percent per Tank
  mutate(percent = count / sum(count) * 100) %>%
  group_by(Cause) %>%                         # summarise across Tanks
  summarise(
    mean_percent = mean(percent),
    sd_percent = sd(percent),
    se_percent = sd_percent / sqrt(n()),
    .groups = "drop"
  ) %>%
  
   # 5. Plot
  ggplot(aes(x = Cause, y = mean_percent, fill = Cause)) +
  geom_col(color = "black", width = 0.7) +
  
  # 6. Error bars, bounded at zero
  geom_errorbar(
    aes(
      ymin = pmax(0, mean_percent - se_percent),
      ymax = mean_percent + se_percent
    ),
    width = 0.2,
    color = "black"
  ) +
  
  # 7. Labels above bars
  geom_text(
    aes(label = sprintf("%.1f%%", mean_percent),y = mean_percent + se_percent + 1),
    vjust = -0.5,
    size = 4,
    color = "black"
  ) +
  
  # 8. Formatting
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  scale_fill_manual(values = c(
    "Moult Failure" = "steelblue3",
    "Cannibalism"   = "royalblue4"
  )) +
  labs(
    x = "Cause of Death",
    y = "Percentage of Mortalities"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "none",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.title.x = element_text(margin = margin(t = 15)),
    axis.title.y = element_text(margin = margin(r = 15)),
    axis.line = element_line(color = "black")
  )
  
```

Bar for condensed cause of mortality co-reared (Raw count)
```{r}

treatments_morts_simplify %>%
  filter(treatment == "group") %>%
    group_by(Cause) %>%
  summarise(count = n(), .groups = "drop") %>%
  
  ggplot(aes(x = Cause, y = count, fill = Cause)) +
 geom_text(aes(label = count),
            vjust = -0.5, size = 4) + # adds % labels above bars
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) + # space for labels
  geom_col(position = "dodge", color = "black") +
   scale_fill_manual(values = c("Moult Failure" = "steelblue3",
                              "Cannibalism" = "royalblue4"))+ 
  labs(
    x = "Cause of Death",
    y = "Number of Mortalities"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "none",
    plot.title = element_text(hjust = 0.5),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.title.x = element_text(margin = margin(t = 15)),
    axis.title.y = element_text(margin = margin(r = 15)),
    axis.line = element_line(color = "black")  # keeps axis lines
  )
  
  
```

Bar plot isolated treatment causes of mortality  (raw counts)
```{r}
treatments_morts_simplify %>%
  filter(treatment == "individual") %>%
    group_by(Cause) %>%
  summarise(count = n(), .groups = "drop") %>%
  
  ggplot(aes(x = Cause, y = count, fill = Cause)) +
  geom_col(position = "dodge", color = "black") +
   geom_text(aes(label = count),
            vjust = -0.5, size = 4) + # adds % labels above bars
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) + # space for labels
   scale_fill_manual(values = c("Moult Failure" = "palegreen3", 
                               "Unknown" = "darkolivegreen4"))+ 
   scale_x_discrete(labels = c("Moult Failure" = "Moult Failure",
                              "Unknown" = "General Attrition")) +
  labs(
    x = "Cause of Death",
    y = "Number of Mortalities"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "none",
    plot.title = element_text(hjust = 0.5),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.title.x = element_text(margin = margin(t = 15)),
    axis.title.y = element_text(margin = margin(r = 15)),
    axis.line = element_line(color = "black")  # keeps axis lines
  )
  
  
```

Both treatments stacked bar (raw count)
```{r}

treatments_morts_simplify %>%
    group_by(Cause, treatment) %>%
  summarise(count = n(), .groups = "drop") %>%
  mutate(Cause = factor(Cause, levels = c("Cannibalism","Unknown","Moult Failure"))) %>% # Set order
  ggplot(aes(x = treatment, y = count, fill = Cause)) +
  geom_col(position = "stack", color = "black") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1)))+
   scale_fill_manual(values = c("Moult Failure" = "grey",
                              "Cannibalism" = "royalblue4",
                              "Unknown" = "darkolivegreen4"), 
                     labels = c("Moult Failure" = "Moult Failure",
                              "Cannibalism" = "Cannibalism",
                              "Unknown" = "General Attrition"))+ 
  scale_x_discrete(labels = c("group" = "Co-reared",
                              "individual" = "Isolated")) +
  labs(
    x = "Treatment",
    y = "Number of Mortalities"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "right",
    plot.title = element_text(hjust = 0.5),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.title.x = element_text(margin = margin(t = 15)),
    axis.title.y = element_text(margin = margin(r = 15)),
    axis.line = element_line(color = "black")  # keeps axis lines
  )
  
  
```

Cannibalism by moult stage bar plot (error bars)
```{r}

treatments_morts_simplify %>%
  filter(treatment == "group") %>%
  filter(Cause != "Moult Failure") %>%
  mutate(Stage = factor(Stage, levels = c("Pre-moult", "Moulting", "Post-moult", "Inter-moult"))) %>%
  group_by(Stage, Tank) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(Tank) %>%
  mutate(percent = count / sum(count) * 100) %>%
  group_by(Stage) %>%
  summarise(
    median_percent = median(percent),
    q1 = quantile(percent, 0.25),
    q3 = quantile(percent, 0.75),
    .groups = "drop"
  ) %>%
  ggplot(aes(x = Stage, y = median_percent, fill = Stage)) +
  geom_col(color = "black", width = 0.7) +
  geom_errorbar(
    aes(
      ymin = q1,
      ymax = q3
    ),
    width = 0.2,
    color = "black"
  ) +
  geom_text(
    aes(label = sprintf("%.1f%%", median_percent), y = q3 + 1),
    vjust = -0.5,
    size = 4,
    color = "black"
  ) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  scale_fill_manual(values = c(
    "Pre-moult" = "steelblue3",
    "Moulting" = "royalblue4",
    "Post-moult" = "cadetblue3", 
    "Inter-moult" = "slategray3"
  )) +
  labs(
    x = "Moult Stage when Cannibalized",
    y = "Median Percentage of Mortalities (IQR)"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "none",
    plot.title = element_text(hjust = 0.5),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.title.x = element_text(margin = margin(t = 15)),
    axis.title.y = element_text(margin = margin(r = 15)),
    axis.line = element_line(color = "black")
  )
```

Cannibalism by time, stacked by moult stage
```{r}

treatments_morts_dets %>%
  filter(treatment == "group") %>%
  filter(status == 1) %>%
  filter(Cause != "Moult Failure") %>%
    group_by(Stage, third) %>%
  mutate(Stage = factor(Stage, levels = c("Pre-moult", "Moulting", "Post-moult", "Inter-moult"))) %>% # Set order
   mutate(third = factor(third, levels = c("Early", "Mid", "Late"))) %>% #order
  summarise(count = n(), .groups = "drop") %>%
  mutate(percent = (count / sum(count)) * 100) %>%
 
  
  ggplot(aes(x = third, y = percent, fill = Stage)) +
  geom_col(position = "fill", color = "black") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
   scale_fill_manual(values = c("Pre-moult" = "steelblue3",
                              "Moulting" = "royalblue4",
                              "Post-moult" = "cadetblue3", 
                              "Inter-moult" = "slategray3"))+  
   scale_x_discrete(labels = c("Early" = "1-10",
                              "Mid" = "11-20",
                              "Late" = "21-30")) +
  labs(
    x = "Days",
    y = "Proportion of Mortalities",
    fill = "Moult Stage"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "right",
    plot.title = element_text(hjust = 0.5),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.title.x = element_text(margin = margin(t = 15)),
    axis.title.y = element_text(margin = margin(r = 15)),
    axis.line = element_line(color = "black")  # keeps axis lines
  )
  
  
```