---
title: "Video Data"
output: html_document
---

## Start up chunk ##

Prep libraries and import datasheets
```{r}

library(tidyverse)
library(coxme)
library(survival)
library(stringr)

video_events <- read_csv("video Notable Events.csv")
video_morts <- read_csv("Mort Counts for Vid Analysis.csv")
no_event_vids <- read_csv("No Event Videos.csv")
video_times <- read_csv("Video Start and Stop Times.csv")
isolated_counts <-read.csv("Isolated_Counts.csv")
halfday_morts <-read.csv("Morts by half day.csv")
treatments_morts_dets <-read.csv("survival_for_curve_plusCauseAndMoult.csv")

#Getting rid of extra spaces that result in fake categories
treatments_morts_dets <- treatments_morts_dets %>%
  mutate(Cause = str_trim(Cause))
```

## Data Wrangling ##

Joining event data sheet with start/stop time sheet and manipulating to create a variable column for real event dates and times
```{r}
#Test events (lights off known time 20:00) show all notable event times coming out within 1.5 seconds of each other accross cameras and within 1.5 seconds of the correct time (20:00). This should be more than sufficient for the timescales I'm working on. 

realtime_events <- video_events %>%
   left_join(video_times, by = "video_code")

realtime_events <- realtime_events %>%
  mutate(
     start_datetime = as.POSIXct(paste(date.x, start), format = "%d-%b-%y %H:%M:%S")) %>%
   separate(timestamp, into = c("hh", "mm", "ss"), sep = ":", convert = TRUE) %>%
  mutate(
    timestamp_seconds = hh * 60 + mm, #what timestamp recognizes as hour is actually minute, minute is second
    real_timestamp_secs  = timestamp_seconds * 29.97,,
    real_timestamp_hms  = seconds_to_period(real_timestamp_secs),
    event_true_datetime = start_datetime + real_timestamp_hms
  )

```

Adding AM/PM and rough time chunks to mortality details summary data frame
```{r}
treatments_morts_dets <- treatments_morts_dets %>%
  mutate(time = ifelse(Day %% 1 == 0, "Night", "Day")) %>%
  mutate(third = case_when(
    Day < 10 ~ "Early",
    Day >= 10 & Day < 20 ~ "Mid",
    Day >= 20 ~ "Late"
  ))

```


Summary table event counts for ease of graphing 
```{r}
events_summary <- realtime_events %>%
  mutate(event_true_date = as.Date(event_true_datetime)) %>% # this is important because in the original date column the date is the day the video started not the actual date (ie things that happen after midnight are not technically the correct date in the original)
  group_by(camera.x, event_true_date, event_type) %>%
  summarise(count = n(), .groups = "drop")
```


Making appropriate data frame for survival curve
```{r}
halfday_morts_long <-halfday_morts %>%
  pivot_longer(
    cols = starts_with("Morts"),
    names_to = "Tank",
    values_to = "Morts"
  )

expanded_morts <- halfday_morts_long %>%
  filter(Morts > 0) %>%
  uncount(weights = Morts, .id = "death_num") %>%
  mutate(
    status = 1  # died
  )

start_counts <- data.frame(
  Tank = c("Morts.I", "Morts.1", "Morts.2", "Morts.3", "Morts.4"),
  start_n = c(44, 11, 11, 11, 11),
  treatment = c("individual", "group", "group", "group", "group")
)

total_morts <- expanded_morts %>%
  count(Tank, name = "Morts")

survivors <- start_counts %>%
  left_join(total_morts, by = "Tank") %>%
  mutate(
    Morts = replace_na(Morts, 0),
    survivors = start_n - Morts
  ) %>%
  filter(survivors > 0) %>%
  uncount(weights = survivors, .id = "survivor_num") %>%
  mutate(
    Day = 30,
    status = 0
  )

survival_data <- bind_rows(
  expanded_morts %>% select(Tank, Day, status),
  survivors %>% select(Tank, Day, status)
) %>%
  left_join(start_counts %>% select(Tank, treatment), by = "Tank") %>%
  mutate(ID = row_number())

survival_for_curve <- survival_data %>%
  group_by(Tank) %>%
  mutate(
    # assign a unique ID *within each tank*
    ID = paste0(Tank, "_", row_number())
  ) %>%
  ungroup()

```


## Survival modeling and visualization between group and individual treatments ##

Kaplan-meier curves and log-rank test for diff between curves, no ability to cluster by tank within group treatment
```{r}

#Make curve df without individuals
survivalCurve_groupOnly <- survival_for_curve %>%
  filter(treatment == "group")

#surv curves for individual vs. group putting all grouped tanks together as a treatment
surv_obj <- Surv(time = survival_for_curve$Day, event = survival_for_curve$status)


survdiff(surv_obj ~ treatment, data = survival_for_curve) #Performs log-rank test to look for differences between survival curves. this groups all the tanks together so it's just grouped vs individual as big groups, cox needed to seperate i think

#surv curves for group only by tank to make sure they aren't significantly different
surv_objGROUP <- Surv(time = survivalCurve_groupOnly$Day, event = survivalCurve_groupOnly$status)
survdiff(surv_objGROUP ~ Tank, data = survivalCurve_groupOnly)


#Kaplan Myer fit with each tank seperated out for visualization
survival_for_curve$tank_or_indiv <- ifelse(is.na(survival_for_curve$Tank), "individual", survival_for_curve$Tank)

# tanks graphed separately
km_fit <- survfit(Surv(Day, status) ~ tank_or_indiv, data = survival_for_curve)

#base r plot of kaplan meier with all tanks separated to show they have similar pattern

plot(km_fit, 
     xlab = "Time (Days)", 
     ylab = "Survival Probability",
     lwd = 2, col = c("turquoise3", "steelblue3", "navyblue", "slategray4", "palegreen3" )) # change pale green to #FF000000 to temporarily remove individual line for presentation plot

# Open a new plotting window (or PDF/PNG) to generate separate figure for legend so it is not ugly
dev.new()  # on RStudio or base R; for saving use png()/pdf()

# Empty plot
plot.new()

#generate legend for prev graph
legend("center", legend = c("Tank 1", "Tank 2", "Tank 3", "Tank 4", "Individuals"),
       col = c("turquoise3", "steelblue3", "navyblue", "slategray4", "palegreen3" ), lwd = 2)  


#tanks graphed together
km_fit_lumped <- survfit(Surv(Day, status) ~ treatment, data = survival_for_curve)

plot(km_fit_lumped, 
     xlab = "Time (Days)", 
     ylab = "Survival Probability",
     lwd = 2, col = c("steelblue3", "palegreen3" ))

# Open a new plotting window (or PDF/PNG) to generate separate figure for legend so it is not ugly
dev.new()  # on RStudio or base R; for saving use png()/pdf()

# Empty plot
plot.new()

#generate legend for prev graph
legend("center", legend = c( "Co-reared", "Isolated"),
       col = c("steelblue3", "palegreen3" ), lwd = 2)

```

KM for cannibalism by moult stage (this is sort of weird, not sure if it's a good representation)
```{r}

#Make curve df for cannibalism by moult stage, censors pure moult failure death
survivalCurve_cann <- treatments_morts_dets %>%
  filter(treatment == "group") %>%
  mutate(status = ifelse(Cause == "Moult Failure", 0, status))
  
#log rank between stages
surv_objCANN <- Surv(time = survivalCurve_cann$Day, event = survivalCurve_cann$status)
survdiff(surv_objCANN ~ Stage, data = survivalCurve_cann)

# curve for just group morts that involved cannibalism by moult stage
km_fit_cann <- survfit(Surv(Day, status) ~ Stage, data = survivalCurve_cann)


#base r plot of kaplan meier with all tanks separated to show they have similar pattern

plot(km_fit_cann, 
     xlab = "Time (Days)", 
     ylab = "Survival Probability",
     lwd = 2, col = c("slategray4", "navyblue", "turquoise3", "steelblue3" )) 

# Open a new plotting window (or PDF/PNG) to generate separate figure for legend so it is not ugly
dev.new()  # on RStudio or base R; for saving use png()/pdf()

# Empty plot
plot.new()

#generate legend for prev graph
legend("center", legend = c( "Co-reared", "Isolated"),
       col = c("steelblue3", "palegreen3" ), lwd = 2)
```


Base Cox proportional hazard models that do not work because of PH assumption, visual of PH assumption indicates changing hazard proportion between groups over time. Two types of cox accounting for tank clustering in diff ways
```{r}

#Cox
# (A) Cox mixed-effects model with tank random intercept (frailty) using coxme
# This treats each group tank as a clustering level ; for individual animals their 'tank' is unique. Treats tank as random effect, assumes each tank has random baseline hazard and estimates variance componant at tank level. Gives fixed effect for treatment and random effect for tank variance. Useful to model tank-to-tank heterogeneity explicitly, not just adjust SEs, output includes frailty variance, but p-values may be approximate.
fit_coxme <- coxme(surv_obj ~ treatment + (1 | Tank), data = survival_for_curve)
print(summary(fit_coxme))

# (B) Alternative: Cox proportional hazards with cluster-robust SE (no random effect estimate). Treats tanks as clusters for robust SEs rather than random effects. Gives treatment effect only but adjusts standard error to account for in-tank correlation. Treatment HR is effect at pop level, SEs and P values should be robust to in-tank correlation. No random effect estimate, so donâ€™t get tank-specific baseline hazards, but I think that's ok because hazard seems vary by time anyway and tanks appear to have similar baseline hazard. I went with this model.
fit_coxph_cluster <- coxph(surv_obj ~ treatment + cluster(Tank), data = survival_for_curve)
summary(fit_coxph_cluster)

# PH assumption check for Cox model (note: coxme has limitations here, PH must be consistant over time, shown by horiz lines on plot check)
# ---------------------------
#for the cox me model:
zph <- cox.zph(fit_coxme)
print(zph)
plot(zph) 

# For the coxph(cluster) model:
zph <- cox.zph(fit_coxph_cluster)
print(zph)
plot(zph)  

# visual check: lines close to horizontal indicate PH reasonable
#Not so, it seems proportional hazard of death between individual and group may change over time, makes sense, few individual deaths toward end. P values of zph indicate the same in both cases

AIC(fit_coxme, fit_coxph_cluster)

```

Taking previous chunk cox model with cluster (option b) and adding time-varying coefficient to allow interaction with log(time). 
```{r}

# Round 2, trying cox with time varying treatment effect as data does not meet PH assumption
# Cox model with time-varying coefficient for treatment 
survival_for_curve$treat_num <- ifelse(survival_for_curve$treatment == "group", 1, 0)

cox_tv <- coxph(Surv(Day, status) ~ treat_num + tt(treat_num) + cluster(Tank),
                data = survival_for_curve,
                tt = function(x, t, ...) x * log(t))  
# tt term allows for interaction with log(time) to address the fact that the PH is not the same over time
# cluster (Tank) tells the model that observations within the same tank are correlated, not independent and adjusts the standard errors and test statistics accordingly (robust sandwich variance), which allows you to still estimate a treatment-level effect while accounting for tank clustering.

summary(cox_tv)
# both treatment number (1,0, group vs. individual) and tt()

# p value for both treat_num (individual vs grouped) and tt(treat_num) are significant, which, with some consultation with chat gpt, means that there is a significant difference between treatments and that the hazard ratio between them varies significantly over time. I think

#Attempting to visualize, chat assisted, might be garbage

# Extract coefficients
b <- coef(cox_tv)
b_treat <- b["treat_num"]
b_tt <- b["tt(treat_num)"]

# Time grid
time_grid <- seq(1, max(survival_for_curve$Day), length.out = 100)

# Hazard ratio over time
HR_t <- exp(b_treat + b_tt * log(time_grid))

plot(time_grid, HR_t, type = "l", lwd = 2,
     xlab = "Time (days)", ylab = "Hazard Ratio (group vs individual)",
     # main = "Time-varying Hazard Ratio"
     )
abline(h = 1, lty = 2, col = "grey")

#Allegedly shows that the proportional hazard of instantaneous death in group vs. individual is like 20 higher by end? Seems a little sus

```

Testing if linear or log-transformed t covariate cox is a better model 
```{r}
# Results are essentially the same, log AIC result is like 0.5 higher which allegedly means the models both fit about equally well. Go with log because everyone loves log time? 

cox_linear <- coxph(Surv(Day, status) ~ treat_num + tt(treat_num) + cluster(Tank), 
                    data = survival_for_curve, 
                    tt = function(x,t,...) x*t)

cox_log <- cox_tv  # current model with log(t)

AIC(cox_linear, cox_log)
```


#Chattage better? version of hazard ratio plot from above with ggplot
```{r}
library(ggplot2)

# Variance-covariance matrix
vc <- vcov(cox_tv)

# Extract coefficients
b_treat <- coef(cox_tv)["treat_num"]
b_tt    <- coef(cox_tv)["tt(treat_num)"]

# Time grid
time_grid <- seq(1, max(survival_for_curve$Day), length.out = 100)

# Linear predictor and variance
lp <- b_treat + b_tt * log(time_grid)
var_lp <- vc["treat_num","treat_num"] +
          (log(time_grid)^2) * vc["tt(treat_num)","tt(treat_num)"] +
          2 * log(time_grid) * vc["treat_num","tt(treat_num)"]

# SE and 95% CI
se_lp <- sqrt(var_lp)
HR_t  <- exp(lp)
lower <- exp(lp - 1.96 * se_lp)
upper <- exp(lp + 1.96 * se_lp)

# Put into data frame
df_hr <- data.frame(
  time  = time_grid,
  HR    = HR_t,
  lower = lower,
  upper = upper
)

# Plot with ribbon
ggplot(df_hr, aes(x = time, y = HR)) +
  geom_ribbon(aes(ymin = lower, ymax = upper), fill = "lightblue", alpha = 0.4) +
  geom_line(color = "blue", size = 1.2) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "grey40") +
  labs(
    x = "Time (days)",
    y = "Hazard Ratio (group vs individual)",
    title = "Time-varying Hazard Ratio with 95% CI"
  ) +
  theme_minimal(base_size = 14)
```



## Chi square/Fisher exact for comparisons without continuous time componant ##

Data formatting
```{r}

#Attributing the causese that include both moult failure and cannibalism to the 'primary' cause of mortality IE did it start struggling with moulting or have a cannibalism attempt first? 
treatments_morts_simplify <- treatments_morts_dets %>%
filter( status == 1) %>%
  mutate(Cause = ifelse(Cause == "Moult Failure + Cannibalism", "Moult Failure", Cause)) %>%
mutate(Cause = ifelse(Cause == "Cannibalism + Moult Failure", "Cannibalism", Cause)) 

  
ctable_cause <- xtabs(~ treatment + Cause, data = treatments_morts_simplify) 
ctable_stage <- xtabs(~ treatment + Stage, data = treatments_morts_simplify) 
ctable_time <- xtabs(~ treatment + time, data = treatments_morts_simplify) 

#ctable_cause
#ctable_stage
#ctable_time

#fisher_cause <- fisher.test(ctable_cause)
#fisher_cause
#fisher_stage <- fisher.test(ctable_stage)
#fisher_stage
fisher_time <- fisher.test(ctable_time)
fisher_time

fisher_by_category(ctable_time)


#code to look at chi square residuals as another check to see what's influencing significant differences (even if doesn't meet assumptions for chi), internet says absolute >2 is usually impactful
chi <- chisq.test(ctable_time, simulate.p.value = TRUE)
residuals <- (ctable_time - chi$expected) / sqrt(chi$expected)
residuals
```

Function to run pairwise fisher for each category table columns
```{r}

fisher_by_category <- function(tab) {
results <- sapply(1:ncol(tab), function(i) {
  tmp <- tab[, i, drop = FALSE]  # 2x1 column
  # Make 2x2 table: cause vs all other deaths
  cause_table <- matrix(c(tab[1, i], sum(tab[1, -i]),
                          tab[2, i], sum(tab[2, -i])),
                        nrow = 2, byrow = TRUE)
  fisher.test(cause_table)$p.value
})

# Adjust for multiple testing (optional)
results_adj <- p.adjust(results, method = "bonferroni")

# Combine into a tidy table
cause_results <- data.frame(
  Cause = colnames(tab),
  raw_p = results,
  bonferroni_p = results_adj
)

cause_results
}
```

Function to run all possible pairwaise fishers to determine where differences lie
```{r}
pairwise_fisher_heat <- function(tab, alpha = 0.05) {
  if (!is.matrix(tab) & !is.table(tab)) stop("Input must be a matrix or table.")
  if (nrow(tab) < 2) stop("Table must have at least 2 rows for pairwise comparison.")
  
  # Generate all pairwise combinations of rows
  row_pairs <- combn(rownames(tab), 2, simplify = FALSE)
  
  results <- lapply(row_pairs, function(p) {
    subtab <- tab[p, , drop = FALSE]  # 2xN table
    res <- fisher.test(subtab)
    data.frame(
      row1 = p[1],
      row2 = p[2],
      raw_p = res$p.value
    )
  })
  
  # Combine results
  df <- do.call(rbind, results)
  
  # Bonferroni correction
  df$bonferroni_p <- p.adjust(df$raw_p, method = "bonferroni")
  
  # Flag significant comparisons
  df$significant <- df$bonferroni_p < alpha
  
  # Create matrix-style heat (optional)
  sig_matrix <- matrix(FALSE, nrow = nrow(tab), ncol = nrow(tab),
                       dimnames = list(rownames(tab), rownames(tab)))
  for (i in 1:nrow(df)) {
    r1 <- df$row1[i]
    r2 <- df$row2[i]
    sig_matrix[r1, r2] <- df$significant[i]
    sig_matrix[r2, r1] <- df$significant[i]  # symmetric
  }
  
  return(list(pairwise_results = df,
              significance_matrix = sig_matrix))
}

```

Function for testing if chi square or fisher exact is more appropriate based on expected counts in contingency table
```{R}

expecteds <- function(tab) {
  # tab = contingency table (matrix or from xtabs)
  
  # Run chi-square without printing immediately
  chi <- suppressWarnings(chisq.test(tab))
  
  # Return expecteds
  chi$expected
  
}

#run_chi_or_fisher(table_x)
```


### Data wrangling WORK IN PROGRESS for possible competing hazard model for cause of death, not current priority. Turns categoricals into number codes in the dataset formatted for survival curves
```{r}
# Turning words into numbers for easier modeling
# Causes of mortality
cause_map <- c("Cannibalism" = 1, "Moult Failure" = 2, "Moult Failure + Cannibalism" = 3, "Cannibalism + Moult Failure" = 4, "Unknown" = 5)
treatments_morts_dets$Cause <- cause_map[treatments_morts_dets$Cause]

# Moult stage
moult_map <- c("Pre-moult" = 1, "Moulting" = 2, "Post-moult" = 3, "Unknown" = 4)
treatments_morts_dets$Stage <- moult_map[treatments_morts_dets$Stage]
```


### Obnoxious Bar Graphs for initial visualization ###

Bar chart for notable events in dif cams
```{r}
#create bar chart showing notable events sans test times and feeds accross all cams
video_events %>%
  group_by(event_type, camera) %>%
  filter(event_type != "Test") %>%
  filter(event_type != "Feed") %>%
  summarize(count = n()) %>%
  ggplot(aes(x = event_type, y = count, fill = factor(camera))) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Notable Events by Camera",
       x = "Event",
       y = "Count") +
  theme_minimal()

```

Bar chart showing notable events by time of day
```{r}

#create bar chart showing notable events sans test by time of day
video_events %>%
group_by(event_type, time_of_day) %>%
  filter(event_type != "Test") %>%
  filter(event_type != "Feed") %>%
  summarize(count = n()) %>%
  ggplot(aes(x = event_type, y = count, fill = time_of_day)) +
  geom_bar(stat = "identity", position = "dodge", color = "darkslategray") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  scale_fill_manual(values = c("am" = "lightcyan2", 
                               "pm" = "darkslategray"), 
                    labels = c("am" = "Light",
                              "pm" = "Dark"))+ 
  labs(
    x = "Event",
    y = "Occurences",
    fill = "Time of Day",
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "right",
    plot.title = element_text(hjust = 0.5),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.title.x = element_text(margin = margin(t = 15)),
    axis.title.y = element_text(margin = margin(r = 15)),
    axis.line = element_line(color = "black")  # keeps axis lines
  )


```

Bar chart showing cannibalism by moult stage
```{r}

#create bar chart total cannibalism morts by moult stage
video_events %>%
group_by(event_type, mort_moult_stage, time_of_day) %>%
  filter(mort_moult_stage != "NA") %>%
  filter(mort_cause == "Cannibalism") %>%
  summarize(count = n()) %>%
   ggplot(aes(x = mort_moult_stage, y = count, fill = time_of_day)) +
  geom_bar(stat = "identity", position = "dodge", color = "darkslategray") +
  scale_y_continuous(
  breaks = seq(0, 10, by = 2),     
  expand = expansion(mult = c(0, 0.1)))  +
  scale_fill_manual(values = c("am" = "lightcyan2", 
                               "pm" = "darkslategray"), 
                    labels = c("am" = "Light",
                              "pm" = "Dark"))+ 
  labs(
    x = "Moult Stage when Cannibalized",
    y = "Occurances",
    fill = "Time of Day",
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "right",
    plot.title = element_text(hjust = 0.5),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.title.x = element_text(margin = margin(t = 15)),
    axis.title.y = element_text(margin = margin(r = 15)),
    axis.line = element_line(color = "black")  # keeps axis lines
  )

#Having the one 'moulting' bar is really ugly and hard to interpret, need to fix if using some iteration of this graph in presentation

```

Bar chart showing moults over time
```{r}
# Moults over the full experiment
moult_tally <- video_events %>%
  filter(event_type == "Moult") %>%   
  group_by(day_number, camera, time_of_day) %>%
  summarise(count = n(), .groups = "drop")

ggplot(moult_tally, aes(x = day_number)) +
  geom_freqpoly(binwidth = 1, size = 1.2, color = "steelblue") +
  labs(x = "Day", y = "Number of Moults") +
    theme_minimal(base_size = 14) +
  theme(
    legend.position = "none",
    plot.title = element_text(hjust = 0.5),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.title.x = element_text(margin = margin(t = 15)),
    axis.title.y = element_text(margin = margin(r = 15)),
    axis.line = element_line(color = "black")  # keeps axis lines
  )
```

Event count per day per tank bar graph using summary table
```{r}
events_summary %>%
  filter(event_type != "Test") %>%
  filter(event_type != "Feed") %>%

ggplot(aes(x = event_true_date, y = count, fill = event_type)) +
  geom_col(position = "dodge") +
  facet_wrap(~camera.x) +
  labs(x = "Date", y = "Count per day", fill = "Event Type") +
  theme_minimal()
```


## Other initial visualizations ##

Moult/Mort visualization by tank frequency point graph thingy, kind of cool visualization 
```{r}
realtime_events %>%
filter(event_type != "Test") %>%
  filter(event_type != "Feed") %>%
ggplot() +
  geom_point(aes(x = event_true_datetime, y = factor(camera.x), color = event_type), size = 3) +
  labs(x = "Time", y = "Tank", color = "Event Type") +
  theme_minimal()
```

## Plots for presentation ##

Bar plot percent mortality
```{r}
plot_data <- treatments_morts_dets %>%
  group_by(treatment) %>%
  summarise(
    num_dead = sum(status == 1),
    total = n(),
    percent_dead = (num_dead / total) * 100,
    mean = mean(percent_dead),
    se = sd(percent_dead) / sqrt(n()),   # standard error
    .groups = "drop"
  )
  

# Optional: order treatments from lowest to highest mortality
plot_data <- plot_data %>%
  mutate(treatment = fct_reorder(treatment, percent_dead))

# Plot
ggplot(plot_data, aes(x = treatment, y = percent_dead, fill = treatment)) +
  geom_col(color = "black") +
  geom_text(aes(label = sprintf("%.1f%%", percent_dead)),
            vjust = -0.5, size = 4) + # adds % labels above bars
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) + # space for labels
  scale_fill_manual(values = c("individual" = "palegreen3", 
                               "group" = "steelblue3"))+ 
   scale_x_discrete(labels = c("individual" = "Isolated",
                              "group" = "Co-reared")) +
  geom_errorbar(aes(ymin = mean - se, ymax = mean + se),
                width = 0.2, size = 0.8) +
  labs(
    x = "Treatment",
    y = "Mortality (%)"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "none",
    plot.title = element_text(hjust = 0.5),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.title.x = element_text(margin = margin(t = 15)),
    axis.title.y = element_text(margin = margin(r = 15)),
    axis.line = element_line(color = "black")  # keeps axis lines
  )
  
```

Bar plot isolated treatment causes of mortality 
```{r}
treatments_morts_simplify %>%
  filter(treatment == "individual") %>%
    group_by(Cause) %>%
  summarise(count = n(), .groups = "drop") %>%
  mutate(percent = (count / sum(count)) * 100) %>%
  
  ggplot(aes(x = Cause, y = percent, fill = Cause)) +
  geom_col(position = "dodge", color = "black") +
   geom_text(aes(label = sprintf("%.1f%%", percent)),
            vjust = -0.5, size = 4) + # adds % labels above bars
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) + # space for labels
   scale_fill_manual(values = c("Moult Failure" = "palegreen3", 
                               "Unknown" = "darkolivegreen4"))+ 
   scale_x_discrete(labels = c("Moult Failure" = "Moult Failure",
                              "Unknown" = "General Attrition")) +
  labs(
    x = "Cause of Death",
    y = "Percentage of Mortalities"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "none",
    plot.title = element_text(hjust = 0.5),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.title.x = element_text(margin = margin(t = 15)),
    axis.title.y = element_text(margin = margin(r = 15)),
    axis.line = element_line(color = "black")  # keeps axis lines
  )
  
  
```

Bar for full causes of mortality co-reared
```{r}

treatments_morts_dets %>%
  filter(treatment == "group") %>%
  filter(status == 1) %>%
    group_by(Cause) %>%
   mutate(Cause = factor(Cause, levels = c("Cannibalism", "Moult Failure", "Cannibalism + Moult Failure", "Moult Failure + Cannibalism"))) %>% # Set order
  summarise(count = n(), .groups = "drop") %>%
  mutate(percent = (count / sum(count)) * 100) %>%
  
  ggplot(aes(x = Cause, y = percent, fill = Cause)) +
 geom_text(aes(label = sprintf("%.1f%%", percent)),
            vjust = -0.5, size = 4) + # adds % labels above bars
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) + # space for labels
  geom_col(position = "dodge", color = "black") +
   scale_fill_manual(values = c("Moult Failure" = "steelblue3",
                              "Cannibalism" = "royalblue4",
                              "Moult Failure + Cannibalism" = "cadetblue3", "Cannibalism + Moult Failure" = "slategray3"))+ 
   scale_x_discrete(labels = c("Moult Failure" = "Moult Failure",
                              "Cannibalism" = "Cannibalism",
                              "Moult Failure + Cannibalism" = "Moult Failure -> Cannibalism", "Cannibalism + Moult Failure" = "Cannibalism -> Moult Failure")) +
  labs(
    x = "Cause of Death",
    y = "Percentage of Mortalities"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "none",
    plot.title = element_text(hjust = 0.5),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.title.x = element_text(margin = margin(t = 15)),
    axis.title.y = element_text(margin = margin(r = 15)),
    axis.line = element_line(color = "black")  # keeps axis lines
  )
  
  
```

Bar for condensed cause of mortality co-reared
```{r}

treatments_morts_simplify %>%
  filter(treatment == "group") %>%
    group_by(Cause) %>%
  summarise(count = n(), .groups = "drop") %>%
  mutate(percent = (count / sum(count)) * 100) %>%
  ggplot(aes(x = Cause, y = percent, fill = Cause)) +
 geom_text(aes(label = sprintf("%.1f%%", percent)),
            vjust = -0.5, size = 4) + # adds % labels above bars
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) + # space for labels
  geom_col(position = "dodge") +
   scale_fill_manual(values = c("Moult Failure" = "steelblue3",
                              "Cannibalism" = "royalblue4"))+ 
  labs(
    x = "Cause of Death",
    y = "Percentage of Mortalities"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "none",
    plot.title = element_text(hjust = 0.5),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.title.x = element_text(margin = margin(t = 15)),
    axis.title.y = element_text(margin = margin(r = 15)),
    axis.line = element_line(color = "black")  # keeps axis lines
  )
  
  
```

Bar for condensed cause of mortality co-reared (Raw count)
```{r}

treatments_morts_simplify %>%
  filter(treatment == "group") %>%
    group_by(Cause) %>%
  summarise(count = n(), .groups = "drop") %>%
  
  ggplot(aes(x = Cause, y = count, fill = Cause)) +
 geom_text(aes(label = count),
            vjust = -0.5, size = 4) + # adds % labels above bars
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) + # space for labels
  geom_col(position = "dodge", color = "black") +
   scale_fill_manual(values = c("Moult Failure" = "steelblue3",
                              "Cannibalism" = "royalblue4"))+ 
  labs(
    x = "Cause of Death",
    y = "Number of Mortalities"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "none",
    plot.title = element_text(hjust = 0.5),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.title.x = element_text(margin = margin(t = 15)),
    axis.title.y = element_text(margin = margin(r = 15)),
    axis.line = element_line(color = "black")  # keeps axis lines
  )
  
  
```

Bar plot isolated treatment causes of mortality  (raw counts)
```{r}
treatments_morts_simplify %>%
  filter(treatment == "individual") %>%
    group_by(Cause) %>%
  summarise(count = n(), .groups = "drop") %>%
  
  ggplot(aes(x = Cause, y = count, fill = Cause)) +
  geom_col(position = "dodge", color = "black") +
   geom_text(aes(label = count),
            vjust = -0.5, size = 4) + # adds % labels above bars
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) + # space for labels
   scale_fill_manual(values = c("Moult Failure" = "palegreen3", 
                               "Unknown" = "darkolivegreen4"))+ 
   scale_x_discrete(labels = c("Moult Failure" = "Moult Failure",
                              "Unknown" = "General Attrition")) +
  labs(
    x = "Cause of Death",
    y = "Number of Mortalities"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "none",
    plot.title = element_text(hjust = 0.5),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.title.x = element_text(margin = margin(t = 15)),
    axis.title.y = element_text(margin = margin(r = 15)),
    axis.line = element_line(color = "black")  # keeps axis lines
  )
  
  
```

Both treatments stacked bar (raw count)
```{r}

treatments_morts_simplify %>%
    group_by(Cause, treatment) %>%
  summarise(count = n(), .groups = "drop") %>%
  mutate(Cause = factor(Cause, levels = c("Cannibalism","Unknown","Moult Failure"))) %>% # Set order
  ggplot(aes(x = treatment, y = count, fill = Cause)) +
  geom_col(position = "stack", color = "black") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1)))+
   scale_fill_manual(values = c("Moult Failure" = "grey",
                              "Cannibalism" = "royalblue4",
                              "Unknown" = "darkolivegreen4"), 
                     labels = c("Moult Failure" = "Moult Failure",
                              "Cannibalism" = "Cannibalism",
                              "Unknown" = "General Attrition"))+ 
  scale_x_discrete(labels = c("group" = "Co-reared",
                              "individual" = "Isolated")) +
  labs(
    x = "Treatment",
    y = "Number of Mortalities"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "right",
    plot.title = element_text(hjust = 0.5),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.title.x = element_text(margin = margin(t = 15)),
    axis.title.y = element_text(margin = margin(r = 15)),
    axis.line = element_line(color = "black")  # keeps axis lines
  )
  
  
```

Cannibalism by moult stage bar plot
```{r}

treatments_morts_dets %>%
  filter(treatment == "group") %>%
  filter(status == 1) %>%
  filter(Cause != "Moult Failure") %>%
    group_by(Stage) %>%
   mutate(Stage = factor(Stage, levels = c("Pre-moult", "Moulting", "Post-moult", "Inter-moult"))) %>% # Set order
  summarise(count = n(), .groups = "drop") %>%
  mutate(percent = (count / sum(count)) * 100) %>%
  
  ggplot(aes(x = Stage, y = percent, fill = Stage)) +
 geom_text(aes(label = sprintf("%.1f%%", percent)),
            vjust = -0.5, size = 4) + # adds % labels above bars
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) + # space for labels
  geom_col(position = "dodge", color = "black") +
   scale_fill_manual(values = c("Pre-moult" = "steelblue3",
                              "Moulting" = "royalblue4",
                              "Post-moult" = "cadetblue3", 
                              "Inter-moult" = "slategray3"))+  
  labs(
    x = "Moult Stage when Cannibalized",
    y = "Percentage of Mortalities"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "none",
    plot.title = element_text(hjust = 0.5),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.title.x = element_text(margin = margin(t = 15)),
    axis.title.y = element_text(margin = margin(r = 15)),
    axis.line = element_line(color = "black")  # keeps axis lines
  )
  
  
```

Cannibalism by time, stacked by moult stage
```{r}

treatments_morts_dets %>%
  filter(treatment == "group") %>%
  filter(status == 1) %>%
  filter(Cause != "Moult Failure") %>%
    group_by(Stage, third) %>%
  mutate(Stage = factor(Stage, levels = c("Pre-moult", "Moulting", "Post-moult", "Inter-moult"))) %>% # Set order
   mutate(third = factor(third, levels = c("Early", "Mid", "Late"))) %>% #order
  summarise(count = n(), .groups = "drop") %>%
  mutate(percent = (count / sum(count)) * 100) %>%
 
  
  ggplot(aes(x = third, y = percent, fill = Stage)) +
  geom_col(position = "fill", color = "black") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
   scale_fill_manual(values = c("Pre-moult" = "steelblue3",
                              "Moulting" = "royalblue4",
                              "Post-moult" = "cadetblue3", 
                              "Inter-moult" = "slategray3"))+  
   scale_x_discrete(labels = c("Early" = "1-10",
                              "Mid" = "11-20",
                              "Late" = "21-30")) +
  labs(
    x = "Days",
    y = "Proportion of Mortalities",
    fill = "Moult Stage"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "right",
    plot.title = element_text(hjust = 0.5),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.title.x = element_text(margin = margin(t = 15)),
    axis.title.y = element_text(margin = margin(r = 15)),
    axis.line = element_line(color = "black")  # keeps axis lines
  )
  
  
```