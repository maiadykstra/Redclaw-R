---
title: "Video Data"
output: html_document
---

## Start up chunk ###

Prep libraries and import datasheets
```{r}

library(tidyverse)
library(coxme)
library(survival)
library(survminer)

video_events <- read_csv("video Notable Events.csv")
video_morts <- read_csv("Mort Counts for Vid Analysis.csv")
no_event_vids <- read_csv("No Event Videos.csv")
video_times <- read_csv("Video Start and Stop Times.csv")
isolated_counts <-read.csv("Isolated_Counts.csv")
halfday_morts <-read.csv("Morts by half day.csv")
treatments_morts_dets <-read.csv("survival_for_curve_plusCauseAndMoult.csv")
```

## Data Wrangling ##

Joining event data sheet with start/stop time sheet and manipulating to create a variable column for real event dates and times
```{r}
#Test events (lights off known time 20:00) show all notable event times coming out within 1.5 seconds of each other accross cameras and within 1.5 seconds of the correct time (20:00). This should be more than sufficient for the timescales I'm working on. 

realtime_events <- video_events %>%
   left_join(video_times, by = "video_code")

realtime_events <- realtime_events %>%
  mutate(
     start_datetime = as.POSIXct(paste(date.x, start), format = "%d-%b-%y %H:%M:%S")) %>%
   separate(timestamp, into = c("hh", "mm", "ss"), sep = ":", convert = TRUE) %>%
  mutate(
    timestamp_seconds = hh * 60 + mm, #what timestamp recognizes as hour is actually minute, minute is second
    real_timestamp_secs  = timestamp_seconds * 29.97,,
    real_timestamp_hms  = seconds_to_period(real_timestamp_secs),
    event_true_datetime = start_datetime + real_timestamp_hms
  )

```

Summary table event counts for ease of graphing 
```{r}
events_summary <- realtime_events %>%
  mutate(event_true_date = as.Date(event_true_datetime)) %>% # this is important because in the original date column the date is the day the video started not the actual date (ie things that happen after midnight are not technically the correct date in the original)
  group_by(camera.x, event_true_date, event_type) %>%
  summarise(count = n(), .groups = "drop")
```

Making appropriate data frame for survival curve
```{r}
halfday_morts_long <-halfday_morts %>%
  pivot_longer(
    cols = starts_with("Morts"),
    names_to = "Tank",
    values_to = "Morts"
  )

expanded_morts <- halfday_morts_long %>%
  filter(Morts > 0) %>%
  uncount(weights = Morts, .id = "death_num") %>%
  mutate(
    status = 1  # died
  )

start_counts <- data.frame(
  Tank = c("Morts.I", "Morts.1", "Morts.2", "Morts.3", "Morts.4"),
  start_n = c(44, 11, 11, 11, 11),
  treatment = c("individual", "group", "group", "group", "group")
)

total_morts <- expanded_morts %>%
  count(Tank, name = "Morts")

survivors <- start_counts %>%
  left_join(total_morts, by = "Tank") %>%
  mutate(
    Morts = replace_na(Morts, 0),
    survivors = start_n - Morts
  ) %>%
  filter(survivors > 0) %>%
  uncount(weights = survivors, .id = "survivor_num") %>%
  mutate(
    Day = 30,
    status = 0
  )

survival_data <- bind_rows(
  expanded_morts %>% select(Tank, Day, status),
  survivors %>% select(Tank, Day, status)
) %>%
  left_join(start_counts %>% select(Tank, treatment), by = "Tank") %>%
  mutate(ID = row_number())

survival_for_curve <- survival_data %>%
  group_by(Tank) %>%
  mutate(
    # assign a unique ID *within each tank*
    ID = paste0(Tank, "_", row_number())
  ) %>%
  ungroup()

```

## Basic survival modeling and visualization between group and individual treatments ##

Kaplan-meier curves and log-rank test for diff between curves, no ability to cluster by tank within group treatment
```{r}

#surv curves for individual vs. group putting all grouped tanks together as a treatment
surv_obj <- Surv(time = survival_for_curve$Day, event = survival_for_curve$status)

survdiff(surv_obj ~ treatment, data = survival_for_curve) #Performs log-rank test to look for differences between survival curves. this groups all the tanks together so it's just grouped vs individual as big groups, cox needed to seperate i think

#Kaplan Myer fit with each tank seperated out for visualization
survival_for_curve$tank_or_indiv <- ifelse(is.na(survival_for_curve$Tank), "individual", survival_for_curve$Tank)

km_fit <- survfit(Surv(Day, status) ~ tank_or_indiv, data = survival_for_curve)

#base r plot of kaplan myer with all tanks seperated to show they have similar pattern

plot(km_fit, 
     xlab = "Time (days)", 
     ylab = "Survival probability",
     main = "Kaplan-Meier: Individuals vs Tanks",
     lwd = 2, col = 1:5)

# Open a new plotting window (or PDF/PNG) to generate seperate figure for legend so it is not ugly
dev.new()  # on RStudio or base R; for saving use png()/pdf()

# Empty plot
plot.new()

#generate legend for prev graph
legend("center", legend = names(km_fit$strata),
       col = 1:5, lwd = 2)  

```


Cox proportional hazard models that do not work because of HP assumption, visual of HP assumption indicates changing hazard proportion between groups over time. Two types of cox accounting for clustering in dif ways
```{r}

#Cox
# (A) Cox mixed-effects model with tank random intercept (frailty) using coxme
# This treats each group tank as a clustering level ; for individual animals their 'tank' is unique. Treats tank as random effect, assumes each tank has random baseline hazard andand estimates variance componant at tank level. Gives fixed effect for treatment and random effect for tank variance. Useful if you want to model tank-to-tank heterogeneity explicitly, not just adjust SEs, output includes frailty variance, but p-values may be approximate.
fit_coxme <- coxme(surv_obj ~ treatment + (1 | Tank), data = survival_for_curve)
print(summary(fit_coxme))

# (B) Alternative: Cox proportional hazards with cluster-robust SE (no random effect estimate). Treats tanks as clusters for robust SEs rather than random effects. Gives treatment effect only but adjusts standard error to account for in-tank correlation. Treatment HR is effect at pop level, SEs and P values should be robust to in-tank correlation. No random effect estimate, so you donâ€™t get tank-specific baseline hazards, but I think that's ok because HP varies by time anyway. I went with this model.
fit_coxph_cluster <- coxph(surv_obj ~ treatment + cluster(Tank), data = survival_for_curve)
summary(fit_coxph_cluster)

# PH assumption check for Cox model (note: coxme has limitations here, HP must be consistant over time, shown by horiz lines on plot check)
# ---------------------------
#for the cox me model:
zph <- cox.zph(fit_coxme)
print(zph)
plot(zph) 

# For the coxph(cluster) model:
zph <- cox.zph(fit_coxph_cluster)
print(zph)
plot(zph)  

# visual check: lines close to horizontal indicate PH reasonable
#Not so, it seems proportional hazard of death between individual and group may change over time, makes sense, few individual deaths toward end. P values indicat the same in both cases

```

Taking previous chunk cox model with cluser (option b) and adding time-varying coefficient to allow interaction with log(time). I don't know if this is the correct way to include time, but the output is nice.
```{r}

# Round 2, trying cox with time varying treatment effect as base data does not meet PH assumption
# Cox model with time-varying coefficient for treatment
survival_for_curve$treat_num <- ifelse(survival_for_curve$treatment == "group", 1, 0)

cox_tv <- coxph(Surv(Day, status) ~ treat_num + tt(treat_num) + cluster(Tank),
                data = survival_for_curve,
                tt = function(x, t, ...) x * log(t))  
# tt term allows for interaction with log(time) to address the fact that the PH is not the same over time
# cluster (Tank) tells the model that observations within the same tank are correlated, not independent and adjusts the standard errors and test statistics accordingly (robust sandwich variance), which allows you to still estimate a treatment-level effect while accounting for tank clustering.

summary(cox_tv)
# both treatment number (1,0 individual vs. grouped) and tt()

# p value for both treat_num (individual vs grouped) and tt(treat_num) are significant, which, with some consultation with chat gpt, means that there is a significant difference between treatments and that the hazard ratio between them varies significantly over time

#Attempting to visualize

# Extract coefficients
b <- coef(cox_tv)
b_treat <- b["treat_num"]
b_tt <- b["tt(treat_num)"]

# Time grid
time_grid <- seq(1, max(survival_for_curve$Day), length.out = 100)

# Hazard ratio over time
HR_t <- exp(b_treat + b_tt * log(time_grid))

plot(time_grid, HR_t, type = "l", lwd = 2,
     xlab = "Time (days)", ylab = "Hazard Ratio (group vs individual)",
     main = "Time-varying Hazard Ratio")
abline(h = 1, lty = 2, col = "grey")

#Nice, so allegedly this show that there is nearly a 20x increased

```

### new
```{r}
# Turning words into numbers for easier modeling
# Causes of mortality
cause_map <- c("Cannibalism" = 1, "Moult Failure" = 2, "Moult Failure + Cannibalism" = 3, "Cannibalism + Moult Failure" = 4, "Unknown" = 5)
treatments_morts_dets$Cause <- cause_map[treatments_morts_dets$Cause]

# Moult stage
moult_map <- c("Pre-moult" = 1, "Moulting" = 2, "Post-moult" = 3, "Unknown" = 4)
treatments_morts_dets$Stage <- moult_map[treatments_morts_dets$Stage]
```


### Bar Graphs ###

Bar chart for notable events in dif cams
```{r}
#create bar chart showing notable events sans test times and feeds accross all cams
video_events %>%
  group_by(event_type, camera) %>%
  filter(event_type != "Test") %>%
  filter(event_type != "Feed") %>%
  summarize(count = n()) %>%
  ggplot(aes(x = event_type, y = count, fill = factor(camera))) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Notable Events by Camera",
       x = "Event",
       y = "Count") +
  theme_minimal()

```

Bar chart showing notable events by time of day
```{r}

#create bar chart showing notable events sans test by time of day
video_events %>%
group_by(event_type, time_of_day) %>%
  filter(event_type != "Test") %>%
  filter(event_type != "Feed") %>%
  summarize(count = n()) %>%
  ggplot(aes(x = event_type, y = count, fill = time_of_day)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Notable Events by Camera",
       x = "Event",
       y = "Count") +
  theme_minimal()


```

Bar chart showing cannibalism by moult stage
```{r}

#create bar chart total cannibalism morts by moult stage
video_events %>%
group_by(event_type, mort_moult_stage, time_of_day) %>%
  filter(mort_moult_stage != "NA") %>%
  filter(mort_cause == "Cannibalism") %>%
  summarize(count = n()) %>%
  ggplot(aes(x = mort_moult_stage, y = count, fill = time_of_day)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Cannibalism Events by Moult Stage",
       x = "Event",
       y = "Count") +
  theme_minimal()

#Having the one 'moulting' bar is really ugly and hard to interpret, maybe should go back and re-watch, classify as either pre, post or unkown. I remeber that vid and it is weird, but the animal DOES appear to be cannibalized immediatedly as it beigns to moult, not after

```

Bar chart showing moults over time
```{r}
# Moults over the full experiment
moult_tally <- video_events %>%
  filter(event_type == "Moult") %>%   
  group_by(day_number, camera, time_of_day) %>%
  summarise(count = n(), .groups = "drop")

ggplot(moult_tally, aes(x = day_number, y = count)) +
  geom_col(position = "dodge") +
  labs(
    title = "Moults by Day",
    x = "Day",
    y = "Moults",
    color = "Camera Number"
  ) +
  theme_minimal()
```

Event count per day per tank bar graph using summary table
```{r}
events_summary %>%
  filter(event_type != "Test") %>%
  filter(event_type != "Feed") %>%

ggplot(aes(x = event_true_date, y = count, fill = event_type)) +
  geom_col(position = "dodge") +
  facet_wrap(~camera.x) +
  labs(x = "Date", y = "Count per day", fill = "Event Type") +
  theme_minimal()
```


## Other initial visualizations ##

Moult/Mort visualization by tank point graph thingy, pretty cool
```{r}
realtime_events %>%
filter(event_type != "Test") %>%
  filter(event_type != "Feed") %>%
ggplot() +
  geom_point(aes(x = event_true_datetime, y = factor(camera.x), color = event_type), size = 3) +
  labs(x = "Time", y = "Tank", color = "Event Type") +
  theme_minimal()
```





